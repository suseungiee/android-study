# day7

### **객체지향 프로그래밍**

### **객체란(Object)**

상태(state), 행동(behavior), 식별자(identity)를 지닌 실체

### **절차 지향 프로그래밍(procedural programming)**

- 하나의 클래스가 다른 여러 클래스의 정보를 너무 많이 알고 있다
- 하나의 클래스가 다른 클래스의 내부 정보를 조작할 수 있다

ㄴ 조작당한 입장에서 어디에서 조작되었는지 확인 어렵다

- 어떤 클래스를 변경시에 가장 중심에 있는 클래스도 변경사항을 알아야한다

    ㄴ 즉 의존성, 결합성(coupling)이 높다

- 프로시저와 데이터를 별도의 모듈에 위치시키는 방식
- 프로시저가 필요한 모든 데이터에 의존적 → 변경에 취약하다

**루틴**

- 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능. 즉 함수, 메서드

**프로시저** : 반환 값이 없이 내부의 상태를 변경하는 것

**함수** : 반환 값이 존재하는 함수

### **객체 지향 프로그래밍**

- 여러 객체가 데이터 공유가 아닌 협력하는 구조

    ㄴ 객체 간 결합도를 낮춘다 (interface를 쓰면 결합도가 낮아진다)

- 객체 내부의 세부 사항을 감추는 캡슐화가 사용된다

캡슐화 사용될수록 객체 간 결합도가 낮다 but 다른 객체에 대한 의존성이 높아질 수 있다. → 책임이 여러객체로 나뉘어 져서.

따라서 의존성, 결합성은 trade off관계

- 즉 프로시저와 데이터를 동일 모듈내에 위치시키는 방식

### **객체지향 설계**

- 각 객체에 책임이 적절하게 분배된다
- 불필요한 의존성을 제거해 객체 사이의 결합도를 낮춘다
- 불필요한 세부사항을 객체 내부로 캡슐화

    ㄴ 객체의 자율성을 높이고 응집도 높은 객체들의 공동체를 창조

### **응집도**

- 모듈에 포함된 내부 요소들이 연관되어있는 정도
- 객체 또는 클래스에 얼마나 관련 있는 책임들을 할당했는지 알 수 있는 지표

측정 방법 : 기능 변경이 발생했을 때 모듈 내부에서 발생하는 변경의 정도로 측정가능

즉 왠만하면 기능 변경이 이루어질때 클래스 한개만 변경하는게 좋다 = 응집도가 높다

### **결합도**

- 의존성의 정도. 다른 모듈에 대해 얼마나 많이 알고있는지
- 객체 또는 클래스가 협력에 필요한 수준의 관계만을 유지하고 있는지 알 수 있는 지표

    ㄴ 객체 하나만 가지고 프로그래밍하지 않으므로 객체간 관계는 필수적이다. 다만 이 관계를 너무 의존적이지않게 해야한다.

측정 방법 : 한 모듈이 변경될 떄 다른 모듈의 변경이 필요한 정도로 측정가능

**즉 응집도가 높을수록, 결합도가 낮을수록 객체 프로그래밍을 잘한것**

**but 이 두개는 trade off관계**

### **추상화 과정**

**추상화 = 모델링**

- 불필요한 정보를 제거하고 현재 문제 해결에 필요한 핵심만 담는 것
- 사물들 간의 공통점은 취하고, 차이점은 버리는 일반화로 단순하게 만든다
- 중요한 부분을 강조하기 위해 불필요한 세부사항을 제거해 단순하게 만든다

즉 객체지향 패러다임은 '역할과 책임을 수행하는' 객체라는 추상화를 통해 복잡성을 극복한다

**프로시저 추상화(procedure abstraction) = Top Down Approach**

- 소프트웨어가 무엇을 해야하는지 추상화한다
- 상위 기능은 단순하고, 더 구체적이며 덜 추상적인 하위 기능의 집합으로 분해된다

ex) 직원 급여 계산 → 세율계산, 직원의 기본급 정보 + 소득세.. 등의 여러 기능으로 분해된다 

→ 기능이 추가되거나 요구사항이 변경되면 어느 부분에 추가해야할 지 판단 어렵다. ex) 직원의 기본급 총합 구하기

**데이터 추상화(data abstraction)**

- 소프트웨엉가 무엇을 알아야하는지 추상화
- **타입 추상화**

    ㄴ 타입에 따라 오퍼레이션을 구현(ex, 비정규직, 정규직 급여 계산함수)

    ㄴ 공통로직은 부모 클래스로 부터 상속받아 개별로 구현 → 다형성 

- 프로시저 추상화

    ㄴ 오퍼레이션을 기준으로 타입을 묶는다

    (ex. 급여계산함수 → 타입별로 if 추가하는 방식)

**타입 추상화가 좀 더 변경에 유연하다. 다형성때문에. OOP에 더 적합**

클래스는 초기에 static영역에 로드되며 ( text영역에 코드 올라간다 )

이후 실행될떄 인스턴스 생성해서 stack, heap으로 올라간다

### **객체 지향 설계는 항상 좋은가?**

- 설계가 필요한 이유는 변경에 대비하기 위함이다
- 설계의 유용성은 변경의 방향성과 발생 빈도에 따라 결정된다.

따라서 진행하는 프로젝트에 맞게 설계를 다양하게 할 수 있으면 된다

### **객체지향 설계의 핵심 - 역할, 책임, 협력**

협력 : 앱의 기능을 구현하기위해 메시지를 주고받는 객체들 사이의 상호작용

책임 : 객체가 다른 객체와 협력하기 위해 수행하는 행동

역할 : 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 역할을 구성 

즉 각 객체는 개별 역할을 가지고있으며 자신의 책임을 다하며 협력하여 프로그래밍을 성공적으로 이끈다

 - 메서드 추가할떄 유연한 구조인지 염두에두기

### **객체 설계 원칙 - SOLID**

- 함수와 데이터 구조를 클래스로 배치하는 방법
- 클래스를 서로 결합하는 방법

목적 : 변경에 유연하고, 이해하기 쉬은 클래스 만들기 위함

**SRP(Single Responsibility Principle) - 단일 책임 원칙**

- 책임 = 변경의 이유. 즉 변경의 이유가 1개, 자기자신의 기능 변경떄문이여야한다.
- 높은 응집도 : 변경의 대상이 명확하므로 코드 변경하기 쉽다
- 낮은 결합도 : 변경해야하는 모듈의 수가 적기떄문에 변경하기 쉽다

**OCP(Open-Closed Principle) - 확장에는 열려있고, 수정에는 닫혀있어야 한다**

확장에 열려있다 = 새로운 기능을 추가할 수 있다

수정에 닫혀있다 = 기존이 코드 변경하지 않고도 동작 추가,  변경 가능하다

**LSP(Liskov Subsititution Principle)** 

- subtype은 언제나 자신의 기반타입(base type)으로 교체 가능할 수 있어야 한다즉 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체 가능

ex) stack, vector → LSP 위반한 상태

stack은 vector를 상속받은 형태. add, remove 가능 but vector의 get을 사용할 수 있으므로 stack의 last in first Out을 쉽게 위반할 수 있다. but stack은 get사용하면 안되는 자료구조이므로 LSP위반한 대표적인 예시

**ISP(Interface Segregation Principle) - 인터페이스 분리 원칙**

- 클라이언트의 요구사항에 맞게 인터페이스를 분리해야한다
- 클라이언트는 자신이 사용하지 않는 메서드를 가지면 안된다

즉 너무 많은 책임을 한 클래스에 넣지 말자

DSP(Dependent Inversion Principle) - 의존성 역전 원칙

상위수준의 클래스(단순 상황)가 하위 수준의 클래스(구체적인 상황)에 의존할 떄 생기는 문제점은?

ㄴ 수정에 취약하다.

즉 유연하고 재사용 가능한 설계를 원한다면 모든 의존성의 방향은 추상클래스나 인터페이스와 같은 추상화를 향해야한다. 

즉 추상클래스나 인터페이스를 상속받은 클래스를 만들어서 사용하자.